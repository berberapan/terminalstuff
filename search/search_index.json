{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Start","text":""},{"location":"#start","title":"Start","text":"<p>Terminalen \u00e4r det mest effektiva s\u00e4ttet att anv\u00e4nda Linux. </p> <p>I den h\u00e4r lilla uppgiften t\u00e4nkte jag g\u00e5 igenom de grundl\u00e4ggande kommandona f\u00f6r att ta sig runt och interagera med systemet.</p> <p>Innan du b\u00f6rjar se till att du har Git installerat.</p> <p>Tryck p\u00e5 'Next' eller navigera i menyn till v\u00e4nster f\u00f6r att ta dig vidare.</p>"},{"location":"1/","title":"1 - Shells","text":""},{"location":"1/#shells","title":"Shells","text":"<p>Vad \u00e4r en terminal? Det \u00e4r ett program som tar emot text-baserade kommandon och kan visa text p\u00e5 sk\u00e4rmen. Programmet som tolkar och k\u00f6r kommandona fr\u00e5n terminalen \u00e4r ett s\u00e5 kallat 'shell'. I Linux-system \u00e4r Bash det vanligaste shell-programmet, men Zsh (Z shell) anv\u00e4nds ocks\u00e5 mycket och \u00e4r \u00e4ven standard i Apple-milj\u00f6er.</p> <p>F\u00f6r att se vilket shell-program ditt system anv\u00e4nder sig av skriv detta kommando i din terminal.</p> <pre><code>echo $SHELL\n</code></pre> <p>I nul\u00e4get beh\u00f6ver du inte t\u00e4nka allt f\u00f6r mycket p\u00e5 dessa shell-filer annat \u00e4n veta att det \u00e4r dessa som k\u00f6r terminalen och att uppgifterna kommer anv\u00e4nda sig av shell-scripts.</p>"},{"location":"2/","title":"2 - L\u00e5t oss s\u00e4tta ig\u00e5ng!","text":""},{"location":"2/#lat-oss-satta-igang","title":"L\u00e5t oss s\u00e4tta ig\u00e5ng!","text":"<p>F\u00f6rst och fr\u00e4mst, klona repot med uppgifter.</p> <pre><code>git clone https://github.com/berberapan/qc-terminal\n</code></pre> <p>N\u00e4r du anv\u00e4nder kommandot ovan s\u00e5 klonar du repot till det directory du befinner dig i. I Linux s\u00e5 \u00e4r hemkatalogens adress <code>/home/(ditt anv\u00e4ndarnamn)</code>. Du kan se var du befinner dig i nul\u00e4get genom att anv\u00e4nda kommandot pwd (print working directory).</p> <pre><code>pwd\n\n# visar exempelvis /home/anv\u00e4ndare\n</code></pre> <p>N\u00e4r qc-terminal \u00e4r klonat s\u00e5 g\u00e5 in i repot. F\u00f6r att g\u00f6ra det s\u00e5 anv\u00e4nder man sig av en av de mest anv\u00e4nda kommandona cd (change directory). </p> <p>Sidosp\u00e5r: I Linux s\u00e5 anv\u00e4nds kataloger (directories). En katalog \u00e4r i princip samma sak som en mapp i Windows. </p> <p>Skriv cd f\u00f6ljt av ditt du vill g\u00e5. F\u00f6r att g\u00e5 tillbaka ett steg anv\u00e4nder du destinationen .. (dubbla punkter). En enkel punkt \u00e4r din nuvarande position.</p> <p>F\u00f6r att g\u00e5 direkt till hemkatalogen kan du anv\u00e4nda en tilde '~' som destination.</p> <pre><code>cd katalognamn    # G\u00e5 in i en katalog\ncd ..          # G\u00e5 tillbaka ett steg\ncd ~           # G\u00e5 direkt till hemkatalogen\ncd ~/Downloads # G\u00e5 till Downloads i hemkatalogen\n</code></pre> <p>Tips: Om du trycker p\u00e5 tab-knappen s\u00e5 auto-completas destinationen om systemet kan hitta den. </p>"},{"location":"2/#uppgift","title":"Uppgift","text":"<p>Orientera dig till Uppgifter/1 i repot du klonade ner och g\u00e5 sedan till n\u00e4sta sida.</p> <p>(Om du har sv\u00e5rt att hitta kan du se vad som finns i nuvarande katalog genom att skriva ls, mer om det kommandot senare)</p>"},{"location":"3/","title":"3 - Echoes of wisdom","text":""},{"location":"3/#echoes-of-wisdom","title":"Echoes of wisdom","text":"<p>Vi borde nu befinna oss i Uppgifter/1. F\u00f6rs\u00e4kra dig att s\u00e5 \u00e4r fallet genom att skriva pwd.</p> <p>P\u00e5 f\u00f6rsta sidan anv\u00e4nde vi echo-kommandot f\u00f6r att se vilket shell-program som anv\u00e4ndes, men vi gick inte in p\u00e5 vad echo \u00e4r. Echo \u00e4r ett simpelt kommando som returnerar text. Om du anger en fil s\u00e5 returneras filnamnet, om du anger en str\u00e4ng s\u00e5 returneras den.</p> <p>N\u00e4r vi kollade p\u00e5 vilket shell-program som anv\u00e4ndes s\u00e5 anv\u00e4nde vi <code>echo $SHELL</code>. H\u00e4r \u00e4r $SHELL en variabel som inneh\u00e5ller s\u00f6kv\u00e4gen till den shell som terminalen anv\u00e4nder.</p> <p>Du kan skapa dina egna variabler i terminalen. F\u00f6r att variabeln ska finnas i shell-milj\u00f6n s\u00e5 m\u00e5ste export anv\u00e4ndas n\u00e4r du skapar den. </p> <pre><code>export min_variabel=\"super\"\necho $min_variabel\n# Skriver ut super\n</code></pre>"},{"location":"3/#uppgift","title":"Uppgift","text":"<p>Skapa en variabel med namn greeting och ge den v\u00e4rdet \"Hello world!\".</p> <p>N\u00e4r du \u00e4r klar k\u00f6r: </p> <pre><code>bash test.sh\n</code></pre> <p>Detta kommer kontrollera att v\u00e4rdet \u00e4r korrekt (kr\u00e4ver att du \u00e4r i Uppgifter/1).</p> <p>Om den ger gr\u00f6nt, g\u00e5 till n\u00e4sta sida.</p>"},{"location":"3/#extra-info","title":"Extra info","text":"<p>Varje ny terminal-session startar i en ny milj\u00f6, vilket betyder att dina variabler inte finns kvar fr\u00e5n f\u00f6rra sessionen. Om du vill att en variabel alltid ska finnas tillg\u00e4nglig m\u00e5ste export-kommandot k\u00f6ras varje g\u00e5ng du loggar in. Detta kan automatiseras genom att l\u00e4gga till kommandot i shell-programmets inst\u00e4llningsfil. Om du \u00e4r nyfiken kan du titta p\u00e5 denna inst\u00e4llningsfil (en s\u00e5 kallad dotfil) som ligger dold i din hemkatalog. F\u00f6r bash-anv\u00e4ndare:</p> <pre><code>cat ~/.bashrc\n</code></pre> <p>Detta \u00e4r s\u00e4rskilt anv\u00e4ndbart n\u00e4r man till exempel vill l\u00e4gga till program i systemets PATH.</p>"},{"location":"4/","title":"4 - Alla dessa flaggor...","text":""},{"location":"4/#alla-dessa-flaggor","title":"Alla dessa flaggor...","text":"<p>G\u00e5 nu till Uppgifter/2.</p> Tips <pre><code>cd ../2\n</code></pre> <p>Innan vi g\u00e5r vidare, h\u00e4r \u00e4r n\u00e5gra anv\u00e4ndbara tricks f\u00f6r terminalen:</p> <ul> <li>Ctrl + l eller clear: Rensar terminalf\u00f6nstret</li> <li>history: Visar tidigare anv\u00e4nda kommandon</li> <li>\u2b06\ufe0f (upp\u00e5t-pilen): Bl\u00e4ddrar genom tidigare kommandon</li> </ul> <p>Nu ska vi g\u00e5 igenom ett viktigt kommando. Tills nu har vi r\u00f6rt oss genom katalogerna utan att egentligen veta vad som finns i dem. F\u00f6r att hj\u00e4lpa oss med det och annat nyttigt s\u00e5 har vi kommandot ls (list).</p> <p>Om du anger endast ls s\u00e5 kommer filer och kataloger i katalogen du befinner dig i att visas. Vilket \u00e4r nyttigt, men m\u00e5nga g\u00e5nger vill man ha lite mer information. D\u00e4rf\u00f6r m\u00e5ste vi b\u00f6rja anv\u00e4nda oss av flaggor. Du har s\u00e4kert anv\u00e4nt flaggor n\u00e4r du hanterat ett projekt i git eller n\u00e4r du anv\u00e4nt dig av curl.</p> <p>Flaggor b\u00f6rjar med antingen - eller dubbla -- f\u00f6ljt av en bokstav eller ord. Exempelvis s\u00e5 kan du oftast f\u00e5 lite hj\u00e4lp med att f\u00f6rst\u00e5 hur ett kommando fungerar genom att skriva <code>--help</code>, vilket oftast \u00e4r flaggan f\u00f6r de kortfattade instruktionerna.</p> <p>Testa g\u00e4rna hj\u00e4lp-flaggan tillsammans med ls f\u00f6r att se outputen. <code>ls --help</code></p> <p>ls har m\u00e5nga anv\u00e4ndbara flaggor, men tv\u00e5 av de mest anv\u00e4nda \u00e4r:</p> <p>-l (long listing format) Denna flagga ger en detaljerad lista med information om varje fil:</p> <ul> <li>R\u00e4ttigheter (vem som f\u00e5r l\u00e4sa/skriva/k\u00f6ra filen)</li> <li>Antal l\u00e4nkar till filen</li> <li>\u00c4gare</li> <li>Grupp\u00e4gare</li> <li>Filstorlek</li> <li>Senast \u00e4ndrad (datum och tid)</li> <li>Filnamn</li> </ul> <p>R\u00e4ttigheterna kommer vi g\u00e5 igenom n\u00e4rmre lite senare. </p> <p></p> <p>-a (all) Som standard visar inte ls dolda filer (filer som b\u00f6rjar med en punkt). Med <code>-a</code> flaggan visas alla filer, inklusive:</p> <ul> <li>Dolda filer (de som b\u00f6rjar med .)</li> <li>Katalogen du st\u00e5r i (.)</li> <li>F\u00f6r\u00e4ldrakatalogen (..)</li> </ul> <p>Du kan ocks\u00e5 kombinera flaggor till en flagga. Till exempel visar <code>ls -la</code> eller <code>ls -al</code> en detaljerad lista \u00f6ver alla filer, inklusive dolda filer.</p> <p>Ett tips \u00e4r att l\u00e4gga till <code>-h</code> (human readable) n\u00e4r du anv\u00e4nder <code>-l</code> f\u00f6r att visa filstorlekar i ett mer l\u00e4sbart format (KB, MB, GB ist\u00e4llet f\u00f6r byte).</p>"},{"location":"4/#uppgift","title":"Uppgift","text":"<p>Precis som i f\u00f6rra delen s\u00e5 skriv <code>bash test.sh</code> f\u00f6r att starta uppgiften.</p> <p>Du kan anv\u00e4nda ls kommandot i skriptet. Ange \"svara\" n\u00e4r du vill svara p\u00e5 en fr\u00e5ga</p>"},{"location":"5/","title":"5 - The cat's pajamas","text":""},{"location":"5/#the-cats-pajamas","title":"The cat's pajamas","text":"<p>N\u00e4st p\u00e5 tur s\u00e5 har vi cat-kommandot. Vi r\u00f6r oss vidare till Uppgifter/3 i terminalen.</p> <p>cat (concatenate) \u00e4r ett av de \u00e4ldsta kommandona som finns i Linux och det fungerar \u00e4ven p\u00e5 f\u00f6rsta versionen av Unix fr\u00e5n 1973. Kommandot kan anv\u00e4ndas f\u00f6r att se vad en fil inneh\u00e5ller utan att beh\u00f6va \u00f6ppna ett separat program.  Anv\u00e4nd <code>cat filnamn</code> och filens inneh\u00e5ll visas direkt i terminalen. Du kan \u00e4ven sammanfoga flera filer samtidigt. Exempelvis <code>cat fil1 fil2 fil3</code> skulle visa alla de tre filernas inneh\u00e5ll en efter en.</p> <p></p> <p>Superbra att kunna se inneh\u00e5llet av filer utan att beh\u00f6va \u00f6ppna n\u00e5gra andra program men det m\u00e5ste v\u00e4l vara n\u00e5got mer man kan g\u00f6ra?  Det kan vara bra att ha koll p\u00e5 Unix-filosofin n\u00e4r vi pratar om kommandon, specifikt de tv\u00e5 f\u00f6rsta punkterna.  </p> <p>Sammanfattning av filosofin p\u00e5 Wikipedia fr\u00e5n McIlroy.</p> <p>Skriv program som g\u00f6r en sak och g\u00f6r det bra. Skriv program som arbetar tillsammans. Skriv program f\u00f6r att hantera textfl\u00f6den eftersom det \u00e4r ett universellt gr\u00e4nssnitt.</p> <p>cat g\u00f6r sin sak v\u00e4ldigt bra, och eftersom den f\u00f6ljer Unix-filosofin s\u00e5 interagerar den v\u00e4ldigt bra med andra kommandon och system. F\u00f6r att demonstrera det s\u00e5 kan vi anv\u00e4nda n\u00e5got som kallas 'redirects' i terminalen, bland annat &gt;, &gt;&gt; och &lt;. Nedan anv\u00e4nder vi de tv\u00e5 f\u00f6rsta tillsammans med cat, &lt; \u00e4r n\u00e5got som inte riktigt beh\u00f6vs med kommandona vi har l\u00e4rt oss hittills men \u00e4r bra att f\u00f6rst\u00e5.</p> <p>Output redirection overwrite (&gt;)</p> <p>&gt; anv\u00e4nds f\u00f6r att skriva output till en fil. Om filen redan existerar s\u00e5 skriver man \u00f6ver den (s\u00e5 h\u00e5ll tungan r\u00e4tt i mun och kontrollera att du skrivit r\u00e4tt filnamn). I exemplet nedan s\u00e5 skrivs det som finns i fil1 och fil2 in tillsammans i en ny tredje fil.</p> <pre><code>cat fil1.txt fil2.txt &gt; fil3.txt\n</code></pre> <p>Det \u00e4r inte bara cat som du kan anv\u00e4nda det h\u00e4r f\u00f6r. Allt som har en output kan anv\u00e4ndas, exempelvis echo som vi tagit upp tidigare kan du anv\u00e4nda f\u00f6r att skapa en ny fil med det som den printar.</p> <pre><code>echo $PATH &gt; minpath.txt\n</code></pre> <p>Output redirection append (&gt;&gt;)</p> <p>&gt;&gt; fungerar som overwrite men l\u00e4gger ist\u00e4llet till output till filen. Exemplet nedan g\u00f6r att inneh\u00e5llet fr\u00e5n fil2 l\u00e4ggs till fil1 ist\u00e4llet f\u00f6r att skapa en ny fil.</p> <pre><code>cat fil2.txt &gt;&gt; fil1.txt\n</code></pre> <p>Input redirection</p> <p>&lt; matar in inneh\u00e5llet fr\u00e5n en fil till ett kommando. Som jag n\u00e4mnde ovan \u00e4r det lite \u00f6verfl\u00f6digt f\u00f6r det vi jobbat med hittills s\u00e5 jag passar p\u00e5 att introducera tv\u00e5 nya kommandon h\u00e4r.</p> <p>Vi kan testa detta med kommandot wc (word count) som r\u00e4knar rader, ord och tecken i en fil. Med flaggan -l r\u00e4knar vi rader.</p> <pre><code>wc -l &lt; fil1.txt\n</code></pre> <p>N\u00e4r vi anv\u00e4nder <code>wc -l &lt; fil1.txt</code> s\u00e5 l\u00e4ser vi inneh\u00e5llet i filen och skickar det direkt till wc-kommandot. Det h\u00e4r kan j\u00e4mf\u00f6ras med <code>wc -l fil1.txt</code> som ger samma resultat. Vad \u00e4r d\u00e5 skillnaden? Varf\u00f6r ens anv\u00e4nda input redirection?</p> <ul> <li>Med <code>wc -l fil1.txt</code> s\u00e5 s\u00e4ger vi \u00e5t wc \"h\u00e4r \u00e4r en fil, l\u00e4s den\"</li> <li>Med <code>wc -l &lt; fil1.txt</code> s\u00e5 s\u00e4ger vi ist\u00e4llet \"h\u00e4r \u00e4r inneh\u00e5llet fr\u00e5n en fil\"</li> </ul> <p>I de flesta fall f\u00e5r du samma resultat, men vissa kommandon \u00e4r byggda f\u00f6r att ta emot inneh\u00e5ll direkt och inte filnamn. Det h\u00e4r \u00e4r ett enkelt exempel p\u00e5 hur olika Unix-kommandon kan samarbeta p\u00e5 olika s\u00e4tt, antingen genom att skicka filer eller inneh\u00e5ll mellan varandra.</p> <p>Innan vi hoppar p\u00e5 uppgifterna s\u00e5 ska jag snabbt n\u00e4mna kommandot sort. Den sorterar text alfabetiskt men kan \u00e4ven sortera p\u00e5 annat, men det f\u00e5r du unders\u00f6ka sj\u00e4lv i --help.</p> <p>S\u00e4g att vi har en fil med olika emailadresser som du vill sortera i alfabetiskt ordning i en ny fil d\u00e5 kan du skriva som i exemplet nedan.</p> <pre><code>sort &lt; emails.txt &gt; sorterade_emails.txt\n</code></pre> <p>Precis som tidigare exempel s\u00e5 g\u00e5r det bra att skriva utan input redirection h\u00e4r d\u00e5 sort kan hantera filnamn utan problem.</p>"},{"location":"5/#uppgift","title":"Uppgift","text":"<p>Starta genom att skriva <code>bash test.sh</code> som vanligt.</p>"}]}